<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tralalerito in Brainrot Map (Chat Toggle Below Controls)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #99ccff;
      font-family: system-ui, sans-serif;
    }
    canvas { display: block; }

    #info {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(255,255,255,0.92);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      color: #111;
      z-index: 60;
    }

    /* Chat container */
    #chatWrap {
      position: absolute;
      right: 18px;
      bottom: 18px;
      width: 460px;
      height: 720px;
      z-index: 55;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: auto;
      transition: transform 220ms ease, opacity 200ms ease;
      transform-origin: 100% 100%;
    }

    #chatHeader {
      height: 52px;
      background: rgba(255,255,255,0.96);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
      font-size: 14px;
      color: #111;
    }

    #chatTitle { font-weight: 600; }

    #chatControls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* The toggle button placed below the header controls */
    #chatFooterControls {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 0 6px;
    }

    #chatFrame {
      width: 100%;
      height: calc(100% - 106px); /* header + footer controls area = 52 + 54 */
      border: none;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
      background: white;
      overflow: hidden;
    }

    button.control {
      background: #ffffffcc;
      border: 1px solid rgba(0,0,0,0.06);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }

    #inlineToggleBtn {
      padding: 8px 12px;
    }

    @media (max-width: 1000px) {
      #chatWrap { width: 360px; height: 600px; right: 12px; bottom: 12px; }
      #chatFrame { height: calc(100% - 106px); }
    }
    @media (max-width: 640px) {
      #chatWrap { width: 300px; height: 520px; right: 8px; bottom: 8px; }
      #chatFrame { height: calc(100% - 106px); }
      #info { font-size: 12px; padding: 6px 8px; }
    }
  </style>
</head>
<body>
  <div id="info">WASD: move (faster) • Arrow ←/→: rotate camera • Space: jump</div>

  <!-- Chat UI: header with controls, then footer controls (toggle below controls), then iframe -->
  <div id="chatWrap" role="region" aria-label="Game chat">
    <div id="chatHeader">
      <div id="chatTitle">Game Chat</div>
      <div id="chatControls">
        <button id="popoutBtn" class="control" title="Open chat in new tab">Pop out</button>
        <button id="settingsBtn" class="control" title="Chat settings">Settings</button>
      </div>
    </div>

    <div id="chatFooterControls">
      <button id="inlineToggleBtn" class="control" aria-pressed="true" title="Show or hide chat">Hide Chat</button>
    </div>

    <iframe id="chatFrame" src="https://betogxzw.netlify.app" title="Chat"></iframe>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

  <script>
    // Chat controls logic: toggle button is below header controls (not overlapping)
    const chatFrame = document.getElementById('chatFrame');
    const inlineToggleBtn = document.getElementById('inlineToggleBtn');
    const popoutBtn = document.getElementById('popoutBtn');

    function setChatVisible(visible) {
      if (visible) {
        chatFrame.style.display = 'block';
        inlineToggleBtn.textContent = 'Hide Chat';
        inlineToggleBtn.setAttribute('aria-pressed', 'true');
      } else {
        chatFrame.style.display = 'none';
        inlineToggleBtn.textContent = 'Show Chat';
        inlineToggleBtn.setAttribute('aria-pressed', 'false');
      }
    }

    // default visible
    let chatVisible = true;
    setChatVisible(chatVisible);

    inlineToggleBtn.addEventListener('click', () => {
      chatVisible = !chatVisible;
      setChatVisible(chatVisible);
    });

    popoutBtn.addEventListener('click', () => {
      window.open(chatFrame.src, '_blank', 'noopener,noreferrer');
    });

    // keyboard toggle with 'C'
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'c' && !e.metaKey && !e.ctrlKey && !e.altKey) {
        chatVisible = !chatVisible;
        setChatVisible(chatVisible);
      }
    });
  </script>

  <!-- Full Tralalerito game logic -->
  <script>
/*
  Complete single-file scene:
  - Tralalerito with speed 0.16 and walking/bounce animations
  - Larger bases (size 12)
  - Continuous mountain perimeter blocking escape
  - Robust raycast ground detection and horizontal AABB blocking
*/

let scene, camera, renderer;
let tralalerito, velocity = 0, canJump = true;
const keys = {};
let cameraAngle = 0;
let walkCycle = 0;
const floorY = 0;
let collisionCandidates = [];
let raycaster;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x99ccff);
  scene.fog = new THREE.Fog(0x99ccff, 60, 160);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 12);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(10, 20, 10);
  scene.add(dir);
  scene.add(new THREE.AmbientLight(0x666666));

  // Ground
  const groundMat = new THREE.MeshLambertMaterial({ color: 0x55aa55 });
  const ground = new THREE.Mesh(new THREE.BoxGeometry(200, 2, 200), groundMat);
  ground.position.y = -1;
  ground.userData.isTerrain = true;
  scene.add(ground);

  // Larger bases (size 12)
  const wallMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  for (let i = 0; i < 4; i++) {
    const size = 12;
    const x = Math.round((Math.random() * 120 - 60) / 4) * 4;
    const z = Math.round((Math.random() * 120 - 60) / 4) * 4;
    const room = new THREE.Group();

    const floor = new THREE.Mesh(new THREE.BoxGeometry(size, 1, size), wallMat);
    floor.position.set(0, 0, 0);
    floor.userData.isSolid = true;
    room.add(floor);

    const ceiling = new THREE.Mesh(new THREE.BoxGeometry(size, 1, size), wallMat);
    ceiling.position.set(0, 5, 0);
    ceiling.userData.isSolid = true;
    room.add(ceiling);

    const wallBack = new THREE.Mesh(new THREE.BoxGeometry(size, 5, 1), wallMat);
    wallBack.position.set(0, 2.5, size/2);
    wallBack.userData.isSolid = true;
    const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(1, 5, size), wallMat);
    wallLeft.position.set(-size/2, 2.5, 0);
    wallLeft.userData.isSolid = true;
    const wallRight = wallLeft.clone();
    wallRight.position.set(size/2, 2.5, 0);
    wallRight.userData.isSolid = true;

    // Door segments (front)
    const doorWidth = 3;
    const segGeom = new THREE.BoxGeometry((size - doorWidth)/2, 5, 1);
    const leftSeg = new THREE.Mesh(segGeom, wallMat);
    leftSeg.position.set(- (doorWidth/2 + (size-doorWidth)/4), 2.5, -size/2);
    leftSeg.userData.isSolid = true;
    const rightSeg = leftSeg.clone();
    rightSeg.position.set((doorWidth/2 + (size-doorWidth)/4), 2.5, -size/2);

    room.add(wallBack, wallLeft, wallRight, leftSeg, rightSeg);

    // interior lamp
    const lamp = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.2,0.8), new THREE.MeshLambertMaterial({ color:0xffee88 }));
    lamp.position.set(0,4.6,0);
    room.add(lamp);

    room.position.set(x, 0, z);
    scene.add(room);
  }

  // Trees
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const leafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
  for (let i = 0; i < 50; i++) {
    const tx = Math.random() * 160 - 80;
    const tz = Math.random() * 160 - 80;
    if (Math.abs(tx) < 8 && Math.abs(tz) < 8) continue;
    const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.6, 0.6), trunkMat);
    trunk.position.set(tx, 1.3, tz);
    scene.add(trunk);
    const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.4, 10, 8), leafMat);
    leaves.position.set(tx, 3.0, tz);
    scene.add(leaves);
  }

  // Mountain perimeter (continuous)
  const mountainMat = new THREE.MeshLambertMaterial({ color: 0x777777 });
  const mapSize = 100; // half-size in each direction; ground spans -100..100 in this scheme
  const wallHeight = 20;
  const wallSize = 10;
  // Build continuous perimeter along edges (tight placement)
  for (let x = -mapSize; x <= mapSize; x += wallSize) {
    // north edge
    const m1 = new THREE.Mesh(new THREE.BoxGeometry(wallSize, wallHeight, wallSize), mountainMat);
    m1.position.set(x, wallHeight/2 - 1, -mapSize);
    m1.userData.isSolid = true;
    scene.add(m1);
    // south edge
    const m2 = new THREE.Mesh(new THREE.BoxGeometry(wallSize, wallHeight, wallSize), mountainMat);
    m2.position.set(x, wallHeight/2 - 1, mapSize);
    m2.userData.isSolid = true;
    scene.add(m2);
  }
  for (let z = -mapSize + wallSize; z <= mapSize - wallSize; z += wallSize) {
    // west edge
    const m3 = new THREE.Mesh(new THREE.BoxGeometry(wallSize, wallHeight, wallSize), mountainMat);
    m3.position.set(-mapSize, wallHeight/2 - 1, z);
    m3.userData.isSolid = true;
    scene.add(m3);
    // east edge
    const m4 = new THREE.Mesh(new THREE.BoxGeometry(wallSize, wallHeight, wallSize), mountainMat);
    m4.position.set(mapSize, wallHeight/2 - 1, z);
    m4.userData.isSolid = true;
    scene.add(m4);
  }

  // Tralalerito (character)
  tralalerito = new THREE.Group();
  const blue = new THREE.MeshLambertMaterial({ color: 0x3399ff });
  const tan = new THREE.MeshLambertMaterial({ color: 0xd2b48c });
  const white = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const black = new THREE.MeshPhongMaterial({ color: 0x000000, shininess: 80 });

  const body = new THREE.Mesh(new THREE.BoxGeometry(1,1,1.1), blue);
  body.position.y = 1.0;
  tralalerito.add(body);

  const face = new THREE.Mesh(new THREE.BoxGeometry(1,0.5,0.8), tan);
  face.position.set(0, 1.25, -0.55);
  tralalerito.add(face);

  const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 12), black);
  leftEye.position.set(-0.28, 1.38, -0.9);
  const rightEye = leftEye.clone();
  rightEye.position.set(0.28, 1.38, -0.9);
  tralalerito.add(leftEye, rightEye);

  const leftShoe = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.28, 0.9), white);
  leftShoe.position.set(-0.36, 0.14, 0.36);
  const rightShoe = leftShoe.clone();
  rightShoe.position.set(0.36, 0.14, 0.36);
  tralalerito.add(leftShoe, rightShoe);

  tralalerito.userData = { leftShoe, rightShoe };
  tralalerito.position.set(0, 2.2, 0);
  scene.add(tralalerito);

  // Build collisionCandidates (explicit flags + size filter)
  collisionCandidates = [];
  scene.traverse(obj => {
    if (obj.isMesh) {
      if (obj.userData.isSolid || obj.userData.isTerrain) {
        collisionCandidates.push(obj);
        return;
      }
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const minSize = Math.min(size.x, size.y, size.z);
      if (minSize > 0.45) collisionCandidates.push(obj);
    }
  });

  // Raycaster for ground detection
  raycaster = new THREE.Raycaster();
  raycaster.far = 4.0;

  // Input listeners
  window.addEventListener('keydown', (e) => { keys[e.code] = true; });
  window.addEventListener('keyup', (e) => { keys[e.code] = false; });

  window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// AABB check for horizontal blocking
function checkCollision(newPos) {
  const halfW = 0.45;
  const halfD = 0.45;
  const min = new THREE.Vector3(newPos.x - halfW, newPos.y, newPos.z - halfD);
  const max = new THREE.Vector3(newPos.x + halfW, newPos.y + 1.8, newPos.z + halfD);
  const charBox = new THREE.Box3(min, max);

  for (let i = 0; i < collisionCandidates.length; i++) {
    const obj = collisionCandidates[i];
    if (tralalerito.children.includes(obj)) continue;
    const box = new THREE.Box3().setFromObject(obj);
    if (box.intersectsBox(charBox)) return true;
  }
  return false;
}

function animate() {
  requestAnimationFrame(animate);

  // Controls and movement
  let moveSpeed = 0.16; // faster as requested
  let rotateSpeed = 0.05;
  let isMoving = false;

  if (keys['ArrowLeft']) cameraAngle += rotateSpeed;
  if (keys['ArrowRight']) cameraAngle -= rotateSpeed;

  // normalize cameraAngle
  if (cameraAngle > Math.PI) cameraAngle -= Math.PI * 2;
  if (cameraAngle < -Math.PI) cameraAngle += Math.PI * 2;

  let dx = 0, dz = 0;
  if (keys['KeyW']) { dx -= Math.sin(cameraAngle) * moveSpeed; dz -= Math.cos(cameraAngle) * moveSpeed; isMoving = true; }
  if (keys['KeyS']) { dx += Math.sin(cameraAngle) * moveSpeed; dz += Math.cos(cameraAngle) * moveSpeed; isMoving = true; }
  if (keys['KeyA']) { dx -= Math.cos(cameraAngle) * moveSpeed; dz += Math.sin(cameraAngle) * moveSpeed; isMoving = true; }
  if (keys['KeyD']) { dx += Math.cos(cameraAngle) * moveSpeed; dz -= Math.sin(cameraAngle) * moveSpeed; isMoving = true; }

  // Horizontal collisions per axis to allow sliding
  let finalDX = dx, finalDZ = dz;
  if (dx !== 0) {
    const testPosX = new THREE.Vector3(tralalerito.position.x + dx, tralalerito.position.y, tralalerito.position.z);
    if (checkCollision(testPosX)) finalDX = 0;
  }
  if (dz !== 0) {
    const testPosZ = new THREE.Vector3(tralalerito.position.x, tralalerito.position.y, tralalerito.position.z + dz);
    if (checkCollision(testPosZ)) finalDZ = 0;
  }
  const testPosBoth = new THREE.Vector3(tralalerito.position.x + finalDX, tralalerito.position.y, tralalerito.position.z + finalDZ);
  if (checkCollision(testPosBoth)) { finalDX = 0; finalDZ = 0; }

  tralalerito.position.x += finalDX;
  tralalerito.position.z += finalDZ;

  // Jump
  if (keys['Space'] && canJump) {
    velocity = 0.32; // stronger jump pairs well with faster movement
    canJump = false;
  }

  // Gravity and clamp
  velocity -= 0.016;
  const maxFall = -1.2;
  if (velocity < maxFall) velocity = maxFall;
  tralalerito.position.y += velocity;

  // Raycast downward for ground detection (short range)
  const rayOrigin = new THREE.Vector3(tralalerito.position.x, tralalerito.position.y + 1.8, tralalerito.position.z);
  raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
  raycaster.far = 3.0; // short ray to avoid hitting distant mountain tops
  const intersects = raycaster.intersectObjects(collisionCandidates, true);

  let groundUnder = floorY;
  if (intersects.length > 0) {
    for (let i = 0; i < intersects.length; i++) {
      const hit = intersects[i];
      const hitPoint = hit.point;
      const hitNormal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0,1,0);
      hitNormal.transformDirection(hit.object.matrixWorld);
      const upDot = hitNormal.dot(new THREE.Vector3(0,1,0));
      const isBelow = hitPoint.y <= tralalerito.position.y + 1.0;
      const horizDistSq = (hitPoint.x - tralalerito.position.x)**2 + (hitPoint.z - tralalerito.position.z)**2;
      // accept surface only if fairly horizontal, actually below, and close horizontally
      if (upDot > 0.7 && isBelow && horizDistSq < 1.1*1.1) {
        groundUnder = hitPoint.y;
        break;
      }
    }
  }

  const snapThreshold = 0.06;
  if (tralalerito.position.y <= groundUnder + snapThreshold) {
    tralalerito.position.y = groundUnder;
    velocity = 0;
    canJump = true;
  }

  // Safety reset if fallen too low
  if (tralalerito.position.y < -40) {
    tralalerito.position.set(0, 6, 0);
    velocity = 0;
    canJump = true;
  }

  // Shoes bounce animation
  const { leftShoe, rightShoe } = tralalerito.userData;
  if (isMoving) {
    walkCycle += 0.28;
    const bounce = Math.abs(Math.sin(walkCycle)) * 0.18;
    leftShoe.position.y = 0.14 + bounce;
    rightShoe.position.y = 0.14 + Math.abs(Math.sin(walkCycle + Math.PI)) * 0.18;
    // slight visual bob (tiny)
    tralalerito.position.y += Math.sin(walkCycle) * 0.0018;
  } else {
    leftShoe.position.y = 0.14;
    rightShoe.position.y = 0.14;
  }

  // Keep upright and rotate
  tralalerito.rotation.y = cameraAngle;

  // Camera follow with clamped vertical offset
  const desiredCamY = Math.min(tralalerito.position.y + 3.6, tralalerito.position.y + 12);
  const camX = tralalerito.position.x + 6 * Math.sin(cameraAngle);
  const camY = desiredCamY;
  const camZ = tralalerito.position.z + 6 * Math.cos(cameraAngle);
  camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.14);
  const maxCameraHeight = tralalerito.position.y + 14;
  if (camera.position.y > maxCameraHeight) camera.position.y = maxCameraHeight;
  camera.lookAt(new THREE.Vector3(tralalerito.position.x, tralalerito.position.y + 1.1, tralalerito.position.z));

  renderer.render(scene, camera);
}
  </script>
</body>
</html>


